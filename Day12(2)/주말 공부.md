- [1] 키워드
- [2] 특정 열을 선택하여 처리하는 커서
- [3] 오류가 발생해도 프로그램이 비정상 종료되지 않도록 하는 예외 처리 

### 전날 복습
```SQL
DECLARE 
    TYPE TAB1 IS TABLE OF EMP%ROWTYPE
    INDEX BY PLS_INTEGER;
    TT TAB1;
    IDX PLS_INTEGER := 0;
BEGIN
    FOR I IN (SELECT * FROM EMP) LOOP
    IDX := IDX + 1;
    TT(IDX).EMPNO := I.EMPNO;
    TT(IDX).ENAME := I.ENAME;
    TT(IDX).JOB := I.JOB;
    TT(IDX).MGR := I.MGR;
    TT(IDX).HIREDATE := I.HIREDATE;
    TT(IDX).SAL := I.SAL;
    TT(IDX).COMM := I.COMM;
    TT(IDX).DEPTNO := I.DEPTNO;
    DBMS_OUTPUT.PUT_LINE(
        TT(IDX).EMPNO||' : '||TT(IDX).ENAME||' : '||TT(IDX).JOB||' : '||TT(IDX).MGR||' : '||TT(IDX).HIREDATE||' : '||TT(IDX).SAL||' : '||TT(IDX).COMM||' : '||TT(IDX).DEPTNO
    );
    END LOOP;
END;
/
```

```
결과::
7369 : SMITH : CLERK : 7902 : 17-DEC-80 : 800 :  : 20
7499 : ALLEN : SALESMAN : 7698 : 20-FEB-81 : 1600 : 300 : 30
7521 : WARD : SALESMAN : 7698 : 22-FEB-81 : 1250 : 500 : 30
7566 : JONES : MANAGER : 7839 : 02-APR-81 : 2975 :  : 20
7654 : MARTIN : SALESMAN : 7698 : 28-SEP-81 : 1250 : 1400 : 30
7698 : BLAKE : MANAGER : 7839 : 01-MAY-81 : 2850 :  : 30
7782 : CLARK : MANAGER : 7839 : 09-JUN-81 : 2450 :  : 10
7788 : SCOTT : ANALYST : 7566 : 09-DEC-82 : 3000 :  : 20
7839 : KING : PRESIDENT :  : 17-NOV-81 : 5000 :  : 10
7844 : TURNER : SALESMAN : 7698 : 08-SEP-81 : 1500 : 0 : 30
7876 : ADAMS : CLERK : 7788 : 12-JAN-83 : 1100 :  : 20
7900 : JAMES : CLERK : 7698 : 03-DEC-81 : 950 :  : 30
7902 : FORD : ANALYST : 7566 : 03-DEC-81 : 3000 :  : 20
7934 : MILLER : CLERK : 7782 : 23-JAN-82 : 1300 :  : 10
```
# 커서와 예외 처리

# 커서란? 
>📌 커서는 `SELECT`문 또는 데이터 조작어 같은 `SQL`문을 실행했을 때 해당 `SQL` 문을 
>처리하는 정보를 저장한 메모리 공간

## `SELECT INTO` 방식
>📌 `SELECT INTO`문은 조회되는 데이터가 단 하나의 행일 떄 사용 가능한 방식.
>커서는 행이 하나이든 여러 개이든 상관없이 사용가능. 

```SQL
SELECT 열1, 열2, 열3, ...,열10 INTO 변수1, 변수2, 변수3, ...,변수10
FROM ...
```

### `SELECT INTO` 를 사용한 단일 행 데이터 저장
```PLSQL 
DECLARE 
	D_ROW DEPT%ROWTYPE;
BEGIN
	SELECT DEPTNO, DNAME, LOC INTO D_ROW
	FROM DEPT 
	WHERE DEPTNO = 40;
	DBMS_OUTPUT.PUT_LINE('부서 번호 : '||D_ROW.DEPTNO);
	DBMS_OUTPUT.PUT_LINE('부서 이름 : '||D_ROW.DNAME);
	DBMS_OUTPUT.PUT_LINE('지역 : '||D_ROW.LOC);
END;
/
```

```SQL
결과::
부서 번호 : 40
부서 이름 : OPERATIONS
지역 : BOSTON
```

>📌 데이터 조회의 결과 값은 하나인 경우보다 여러 개의 경우가 흔하기 때문에 
>결과 행이 하나일지 여러개일지 알 수 없는 경우도 있기에 대부분 커서를 활용한다.

## 명시적 커서 
>📌 `명시적 커서` : 사용자가 직접 커서를 선언하고 사용하는 커서 

| 단계  | 명칭              | 설명                                                                                                                |
| --- | --------------- | ----------------------------------------------------------------------------------------------------------------- |
| 1단계 | 커서 선언           | 사용자가 직접 이름을 지정하여 사용할 커서를 `SQL`문과 함께 선언                                                                            |
| 2단계 | 커서 열기           | 커서를 선언할 때 작성한 `SQL`문을 실행. <br>이때 실행한 `SQL`문에 영햘을 받는 행을 <br>`ACTIVE SET`이라고 한다.                                    |
| 3단계 | 커서에서 읽어온 데이터 사용 | 실행된 `SQL`문의 결과 행 정보를 하나씩 읽어 와서 변수에 저장한 후 필요한 작업을 수행한다. <br>각 행별로 공통 작업을 반복해서 실행하기 위해 여러 종류의 `LOOP`문과 함께 사용할 수 있다. |
| 4단계 | 커서 닫기           | 모든 행의 사용이 끝나고 커서를 종료.                                                                                             |
### `PL/SQL` 명시적 커서 작성 방법
```SQL
DECLARE 
	CURSOR 커서 이름 IS SQL문; -- 명시저 커서 선언(DECLARATION)
BEGIN 
	OPEN 커서 이름; -- 커서 열기(OPNE)
	FETCH 커서이름 INTO 변수; --커서로부터 읽어온 데이터 사용(FETCH)
	CLOSE 커서이름; -- 커서 닫기(CLOSE)
END
```

## 하나의 행만 조회되는 경우
>📌 하나의 행만 조회되는 `SELECT` 문을 커서로 지정하여 사용할 경우, 
>`SELECT INTO`방식보다 복잡해진다. `CURSOR`는 조회되는 행이 여러 개일 때 극대화된다.

```SQL
DECLARE 
--커서 데이터를 입력할 수 있는 변수 선언
D_ROW DEPT%ROWTYPE;
--명시적 커서 선언(DECLARATION)
CURSOR C1 IS
	SELECT DEPTNO, DNAME, LOC
	FROM DEPT 
	WHERE DEPTNO = 40;
BEGIN 
-- 커서 열기
OPEN C1
-- 커서로 부터 읽어온 데이터 사용(FETCH)
FETCH C1 INTO D_ROW;
DBMS_OUTPUT.PUT_LINE(D_ROW.DEPTNO||' : '||D_ROW.DNAME||' : '||D_ROW.LOC)
CLOSE C1; -- 커서닫기
END;
/
```

```
40 : OPERATIONS : BOSTON
```

> ### 📌`LINE BY LINE`
> **03행** : 커서의 `DEPT`테이블 조회 데이터를 저장할 변수를 선언한다. 
> **06행~08행** : 사용할 `SELECT`문을 지정하여 커서의 이름(`C1`)을 선언한다. 
> **11행** : `C1` 커서를 열어 `ACTIVE SET`을 식별한다. 
> **13행** : `FETCH INTO`문을 사용하여 `ACTIVE SET`에서 결과 행을 추출하고 `INTO`절에 
> 	명시한 `D_ROW`변수에 대입한다.
> **16행** : `D_ROW`변수에 저장한 데이터를 출력(사용)한다.
> **17행** : 커서에 지정한 `SELECT`문의 결과 행 처리가 모두 끝나면 커서를 닫는다. 
> 	이후에 필요하다면 **커서를 다시 열어서 사용**할 수 있다.
### 나의 실험
```SQL
DECLARE 
    D_ROW DEPT%ROWTYPE;
    CURSOR C1 IS
    SELECT * FROM DEPT WHERE DEPTNO = 40;
BEGIN
    OPEN C1;
    FETCH C1 INTO D_ROW;
    DBMS_OUTPUT.PUT_LINE(D_ROW.DEPTNO||' : '||D_ROW.DNAME||' : '||D_ROW.LOC);
    CLOSE C1;
END;
/
```

> 💡왠지 동일한 결과가 나올 듯 하여 해봤는데 역시 똑같은 결과가 나온다.

## 여러 행의 데이터를 커서에 저장하여 사용하기(`LOOP`)
```SQL
DECLARE 
--커서 데이터를 입력할 수 있는 변수 선언
D_ROW DEPT%ROWTYPE;
--커서 DECLARATION 
CURSOR C1 IS
	SELECT * FROM DEPT;
BEGIN
--OPEN
OPEN C1;
	LOOP
	FETCH C1 INTO D_ROW;
	EXIT WHEN C1%NOTFOUND;
	DBMS_OUTPUT.PUT_LINE(D_ROW.DEPTNO||' : '||D_ROW.DNAME||' : '||D_ROW.LOC);
	END LOOP;
CLOSE C1;
END;
/
```

```
결과::
10 : ACCOUNTING : NEW YORK
20 : RESEARCH : DALLAS
30 : SALES : CHICAGO
40 : OPERATIONS : BOSTON
```

| 속성              | 설명                                                     |
| --------------- | ------------------------------------------------------ |
| `커서이름%NOTFOUND` | 수행된 `FETCH`문을 통해 추출된 행이 있으면 `FALSE`, 없으면 `TRUE`를 반환한다. |
| `커서이름%FOUND`    | 수행된`FETCH`문을 통해 추출된 행이 있으면 `TRUE` 아니면 `FALSE`반환        |
| `커서이름%ROWCOUNT` | 현재까지 추출된 행 수를 반환                                       |
| `커서이름%ISOPEN`   | 커서가 열려있으면 TRUE 아니라면 FALSE                              |

### 나의 실습? 예제?

```PLSQL
DECLARE    
    CURSOR C1 IS 
    SELECT * FROM DEPT;
BEGIN
    FOR I IN C1() LOOP
    DBMS_OUTPUT.PUT_LINE(I.DEPTNO||' : '||I.DNAME||' : '||I.LOC);
    END LOOP;
END;
/
```

>💡 이건 왜 되는거지 ... 
> `OPEN`, `FETCH`, `CLOSE`를 전혀 사용하지 않아도 동일한 결과가 나오는데 
> 왜 예제에선 
> 굳이 `LOOP`랑 `EXIT WHEN`을 사용하면서 까지 `OPEN` `FETCH` `CLOSE`를 사용한지 
> 모르겠다. -> 아마 뒤에나오는 `%NOTFOUND`같은 속성을 학습하기 위해?

## 여러 개의 행이 조회 되는 경우(`FOR LOOP`)
```SQL
FOR 루프 인덱스 이름 IN 커서 이름 LOOP
	결과 행별로 반복 수행할 작업;
END LOOP;
```

>📌 루프 인덱스는 커서에 저장된 각 행이 저장되는 변수를 뜻하며, `.`을 통해 
>행의 각 필드에 접근 할 수 있다. 
>커서에 `FOR LOOP` 문을 사용하면 `OPEN`, `FETCH`, `CLOSE`를 작성하지 않는다. 
> -> 역시 사람말은 끝까지 들어봐야.. 안 나올 수가 없는데 ㅋㅋ

### `FOR LOOP`문을 활용하여 커서 사용하기
```SQL
DECLARE 
--명.커(명시적커서)
CURSOR C1 IS 
SELECT * FROM DEPT;
BEGIN 
--FOR LOOP
FOR I IN C1() LOOP
DBMS_OUTPUT.PUT_LINE('번호 : '||I.DEPTNO||', 이름 : '||I.DNAME||', 지역 : '||I.LOC);
END LOOP;
END;
/
```

```
결과::
번호 : 10, 이름 : ACCOUNTING, 지역 : NEW YORK
번호 : 20, 이름 : RESEARCH, 지역 : DALLAS
번호 : 30, 이름 : SALES, 지역 : CHICAGO
번호 : 40, 이름 : OPERATIONS, 지역 : BOSTON
```

>💡 `FOR LOOP` 에선 `OPEN FETCH CLOSE` 자동!

## 커서에 파라미터 사용하기
>📌 지금까지는 커서에 지정한 `SQL`문을 그대로 사용했다.
>하지만 고정 값이 아닌 직접 입력한 값 또는 상황에 따라 여러 값을 번갈아 사용하려면
>다음과 같이 커서에 파라미터를 지정할 수 있다.

```SQL 
CURSOR 커서 이름(파라미터 이름 자료형, ...) IS 
SELECT ...
```

### 파라미터를 사용하는 커서 알아보기
```SQL
DECLARE 
	--커.변(커서 데이터를 입력할 변수)
	D_ROW DEPT%ROWTYPE;
	--명.커
	CURSOR C1(D_NUM DEPT.DEPTNO%TYPE) IS 
	SELECT DEPTNO, DNAME, LOC 
	FROM DEPT 
	WHERE DEPTNO = D_NUM;
BEGIN 
	--10번(부서번호)을 대입
	OPEN C1(10); LOOP --OPEN
	FETCH C1 INTO D_ROW;
	EXIT WHEN C1%NOTFOUND
	DBMS_OUTPUT.PUT_LINE('번호 : '||D_ROW.DEPTNO||' 이름 : '||D_ROW.DNAME||' 장소 : '||D_ROW.LOC);
	END LOOP;
	CLOES C1;
	--20번 부서(내맘대로 FOR로 바꿔버리기)
	FOR I IN C1(20) LOOP
	DBMS_OUTPUT.PUT_LINE('번호 : '||I.DEPTNO||' 이름 : '||I.DNAME||' 장소 : '||I.LOC)
	END LOOP;
END;
/	
```

```
결과::
번호 : 10 이름 : ACCOUNTING 장소 : NEW YORK
번호 : 20 이름 : RESEARCH 장소 : DALLAS
```

>💡 2번째 예제도 `FOR LOOP`문을 적용할 수 있을 듯 하여 
>코드의 양을 줄이고 가독성을 위해 20번 부서 예제는 `FOR LOOP`로 변경하였다.

> **05행** : 커서에서 사용 될 `D_NUM`을 정의하였다.
> **08행** : 선언된 파라미터 `D_NUM`은 `SELECT`문의 `WHERE`절에서 `DEPTNO`열과의 비교값으로 사용한다.
> **11행** : `DECLARE`시에 `C1`커서에 파라미터를 지정하였으므로, `OPEN`할 때 `C1(10)`과 같이 자료형을 맞추어 파라미터에 값을 지정해야한다. 
> `C1(10)`은 10이 `D_NUM`에 지정되므로, `SELECT`문은 `WHERE DEPTNO = 10(D_NUM값)`이 된다.
> **18행** : 20번 부서도 동일한 동작을 수행한다(`FOR LOOP`문을 사용하여 `OPEN, FETCH, CLOSE`과정을 생략하였다.)

### 커서에 사용할 파라미터 입력받기
```SQL
DECLARE 
--사용자가 입력한 부서 번호를 저장하는 변수
I_NUM DEPT.DEPTNO%TYPE;
CURSOR C1 (D_NUM DEPT.DEPTNO%TYPE) IS 
SELECT DEPTNO, DNAME, LOC 
FROM DEPT 
WHERE DEPTNO = D_NUM;
BEGIN 
--I_NUM 입력값 받고 , D_NUM 으로 넘겨준다.
I_NUM := &INPUT_DEPTNO;
--FOR LOOP
FOR I IN C1(I_NUM) LOOP
DBMS_OUTPUT.PUT_LINE('번호 : '||I.DEPTNO||' 이름 : '||I.DNAME||' 지역 : '||I.LOC);
END LOOP;
END;
```

![[Pasted image 20240414233641.png]]
```
결과::
번호 : 20 이름 : RESEARCH 지역 : DALLAS
-- 진짜 신기하네 ..
```

> **03행** : 사용자가 직접 입력한 부서 번호를 저장하는 I_NUM 변수 선언
> **04행** : 커서가 사용하는 파라미터 D_NUM 선언
> **07행** : 선언된 변수 `D_NUM`은 커서에 지정된 `SELECT`문의 `DEPTNO`와 비교
> **** : `&INPUT_DEPTNO` 를 사용해서 사용자에게 `INPUT_DEPTNO` 에 들어갈 값의 입력을 요구. 해당 값을 `I_NUM`에 저장
> **12행** : C1커서에 `I_NUM` 변수를 대입하여 실행! `WHERE`절에서 이 값을 사용!

>💡정말 신기하고 재밌는데 .. 이상하게 지친다
>자꾸 반복되는 테이블 (`DEPT`, `EMP`)만 사용하여서 그런걸까? 저 두 테이블은 안보고도 
>컬럼명을 다 쓸 정도가 되었다..