# PL/SQL 
# 조건 제어문
>📌 특정 조건식을 통해 상화에 따라 실행할 내용을 달리하는 방식의 명령어를 조건문이라 한다. 
>`PL/SQL` 에서는 `IF`  문과 `CASE` 문을 사용할 수 있다.

| 종류             | 설명                                  |
| -------------- | ----------------------------------- |
| IF-THEN        | 특정 조건을 만족하는 경우 작업 수행                |
| IF-THEN-ELSE   | 특정 조건을 만족하는 경우와 반대 경우에 각각 지정한 작업 수행 |
| IF-THEN-ELSEIF | 여러 조건에 따라 각각 지정한 작업 수행              |

## IF 조건문
### IF-THEN 
```PLSQL
IF 조건식 THEN -- TRUE OR FALSE 판별이가능한 조건식 , 연산자 및 함수
	수행할 명령어 -- TRUE 면 실행할 명령어 지정
END IF; -- IF 종료
```

### IF-THEN-ELSE 
```PLSQL
IF 조건식 THEN
	수행할 명령어
ELSE 
	수행할 명령어
END IF;
```

### IF-THEN-ELSEIF 
```PLSQL
IF 조건식 THEN
	수행할 명령어1
ELSIF
	수행할 명령어2
ELSE
	수행할 명령어3
END IF;
```

### 나의 예제
```PLSQL

DECLARE 
    SCORE NUMBER DEFAULT 98;
BEGIN
    IF SCORE = 100 THEN DBMS_OUTPUT.PUT_LINE('A+');
    ELSIF SCORE >= 90 THEN DBMS_OUTPUT.PUT_LINE('A');
    ELSIF SCORE >= 80 THEN DBMS_OUTPUT.PUT_LINE('B'); 
    ELSIF SCORE >= 70 THEN DBMS_OUTPUT.PUT_LINE('C');
    ELSIF SCORE >= 60 THEN DBMS_OUTPUT.PUT_LINE('D');
    ELSE DBMS_OUTPUT.PUT_LINE('F');
    END IF;
END;
/
```

```PLSQL
DECLARE 
    V_NUM NUMBER DEFAULT 15;
BEGIN 
    IF MOD(V_NUM , 2) = 0  THEN
    DBMS_OUTPUT.PUT_LINE('짝수');
    ELSE 
    DBMS_OUTPUT.PUT_LINE('홀수');
    END IF;
END;
/
-- 홀짝 판
```

## CASE 조건문 
| 종류       | 설명                                         |
| -------- | ------------------------------------------ |
| 단순 CASE문 | 비교 기준이 되는 조건의 값이 여러 가지일 때 해당 값만 명시하여 작업 수행 |
| 검색 CASE문 | 특정한 비교 기준 없이 여러 조건식을 나열하여 조건식에 맞는 작업 수행    |
### 단순 CASE
>📌 여러 가지 결과 값이 나올 수 있는 변수 또는 식을 명시

```PLSQL
CASE 비교 기준 -- 변수, 혹은 표현식
	WHEN 값1 THEN 수행할 명령어1 
	WHEN 값2 THEN 수행할 명령어2 
	WHEN 값3 THEN 수행할 명령어3 -- 비교 기준이 일치하면 작업 수행 나머지 무시
	ELSE 수행할 명령어ELSE -- 일치값이 없으면 해당 작업 수행
END CASE; -- CASE 문 종료
```

### 나의 예제
```PLSQL

DECLARE 
    SCORE NUMBER DEFAULT 75; 
BEGIN
    CASE TRUNC(SCORE/10) -- TRUNC : 소수점 버림 // 10으로 나누고 소수점버림
    WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('A+');
    WHEN 9 THEN DBMS_OUTPUT.PUT_LINE('A');
    WHEN 8 THEN DBMS_OUTPUT.PUT_LINE('B');
    WHEN 7 THEN DBMS_OUTPUT.PUT_LINE('C');
    WHEN 6 THEN DBMS_OUTPUT.PUT_LINE('D');
    ELSE DBMS_OUTPUT.PUT_LINE('F');
    END CASE;
END;
/ 
-- 학점계산
```

### 검색 CASE 
```PLSQL
CASE
	WHEN 조건식1 THEN 수행명령어1; 
	WHEN 조건식2 THEN 수행명령어2; 
	WHEN 조건식3 THEN 수행명령어3;
	ELSE 수행명령어4;
END CASE; 
```

### 나의 예제

```PLSQL
DECLARE 
    SCORE NUMBER DEFAULT 84;
BEGIN 
    CASE
        WHEN SCORE = 100 THEN DBMS_OUTPUT.PUT_LINE('A+');
        WHEN SCORE >= 90 THEN DBMS_OUTPUT.PUT_LINE('A');
        WHEN SCORE >= 80 THEN DBMS_OUTPUT.PUT_LINE('B');
        WHEN SCORE >= 70 THEN DBMS_OUTPUT.PUT_LINE('C');
        WHEN SCORE >= 60 THEN DBMS_OUTPUT.PUT_LINE('D');
        ELSE DBMS_OUTPUT.PUT_LINE('F');
    END CASE;
END;
/
-- 위랑 동일 
```

# 반복 제어문 

# LOOP

> 📌특정 작업을 반복하여 수행하고자 할 때 사용, `PL/SQL` 에선 네 가지 반복문을 제공하고 있다. 

| 종류             | 설명                   |
| -------------- | -------------------- |
| 기본 LOOP        | 기본 반복문               |
| WHILE LOOP     | 특정 조건식의 결과를 통해 반복 수행 |
| FOR LOOP       | 반복 횟수를 정하여 반복 수행     |
| CUSOR FOR LOOP | 커서를 활용한 반복 수행        |

>📌반복 수행을 중단시키거나 특정 반복 주기를 건너뛰는 명령어 

| 종류            | 설명                                   |
| ------------- | ------------------------------------ |
| EXIT          | 수행 중인 반복 종료                          |
| EXIT-WHEN     | 반복 종료를 위한 조건식을 지정하고 만족하면 반복 종료       |
| CONTINUE      | 수행 중인 반복의 현재 주기를 건너뜀                 |
| CONTINUE-WHEN | 특정 조건식을 지정하고 조건식을 만족하면 현재 반복 주기를 건너뜀 |
## 기본 LOOP 
>📌별다른 조건 없이 작업을 반복

```PLSQL
LOOP
 반복 수행 작업;
END LOOP; -- 무한 반복
```

>📌 기본 `LOOP` 는 별다른 설정을 하지 않으면, 무한히 반복하기 때문에,
>반복을 종료하는 `EXIT` 명령어와 함께쓰는 경우가 대부분이다.

### 나의 예제

```PLSQL 
DECLARE 
	V_NUM NUMBER DEFAULT 0;
BEGIN 
	LOOP
	DBMS_OUTPUT.PUT_LINE('NUMBER : '||V_NUM);
	V_NUM := V_NUM + 1;
	EXIT WHEN V_NUM = 10;
	END LOOP;
END;
/
```

## WHILE LOOP 
>📌 조건식을 먼저 지정 후, TRUE 이면 반복, FALSE 면 종료

```PLSQL
WHILE 조건식 LOOP
	반복 수행 작업; 
END LOOP;
```

### 나의 예제
```PLSQL
DECLARE 
    V_NUM NUMBER := 1;
    V_STR VARCHAR2(20) DEFAULT NULL;
BEGIN 
    LOOP
        V_STR := '*'||V_STR;
        DBMS_OUTPUT.PUT_LINE(V_STR);
        V_NUM := V_NUM + 1;
    EXIT WHEN V_NUM > 8;
    END LOOP;
END;
/
-- 간단한 별찍기 
```

```
::결과
*
**
***
****
*****
******
*******
********
```

## FOR LOOP
> 📌 FOR LOOP 문에서 바로 정의하여 사용할 수 있는 `카운터` 변수에 값을 임시로 할당하여 반복

```PLSQL
FOR I IN 1..10 LOOP
	반복 수행 작업;
END LOOP;
```

### 나의 예제
```PLSQL

DECLARE 
    V_STR VARCHAR2(20) DEFAULT NULL;
BEGIN
    FOR I IN 1..10 LOOP
        V_STR := '*'||V_STR;
        DBMS_OUTPUT.PUT_LINE(V_STR);
    END LOOP;
END;
/
-- 순차 별찍기
```

```PLSQL

DECLARE
    STR VARCHAR2(20) DEFAULT NULL;
BEGIN
    FOR I IN 1..10 LOOP
    STR := NULL;
        FOR J IN  I..10 LOOP
        STR := '*'||STR;
        END LOOP;
    DBMS_OUTPUT.PUT_LINE(STR);
    END LOOP;
END;
/
    -- 이중 FOR문 거꾸로 별찍기 
```

```PLSQL
BEGIN 
    FOR I IN 1..10 LOOP
    CONTINUE WHEN MOD(I, 2) = 0;
    DBMS_OUTPUT.PUT_LINE('NUMBER : '||I);
    END LOOP;
END;
/
-- 홀수 출력
```

📌 값을 역순으로 반복

```PLSQL
FOR I IN REVERSE 1..10 LOOP
	반복 수행 작업;
END LOOP;
```

```PLSQL
BEGIN 
	FOR I IN REVERSE 1..10 LOOP
		DBMS_OUTPUT.PUT_LINE('NUMBER : '||I);
	END LOOP;
END;
/
```

## CONTINUE, CONTINUE_WHEN 
> 📌 ORACLE 11G 버전부터 사용 가능
> 반복 중 CONTINUE 가 실행되면 남아있는 작업을 건너뛰고 다음 반복 주기로 바로 넘어감.

```PLSQL
BEGIN 
	FOR I IN 0..10 LOOP
		CONTINUE WHEN MOD(I, 2) = 1;
		DBMS_OUTPUT.PUT_LINE('NUMBER : '||I);
	END LOOP;
END;
/
```

## 나의 종합 예제
```PLSQL
DECLARE 
    V_DEPTNO DEPT.DEPTNO%TYPE := 20;
    V_DNAME DEPT.DNAME%TYPE;
BEGIN  
    SELECT DNAME INTO V_DNAME
    FROM DEPT 
    WHERE DEPTNO = V_DEPTNO;
    DBMS_OUTPUT.PUT_LINE('DNAME : '||V_DNAME);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('DNAME : '||'N/A');
END;
/
-- DEPTNO 값이 존재하면 DNAME을 출력 , 만약 없다면 N/A 출력 

```

```PLSQL
--CASE WHEN 으로도 해결가능
DECLARE 
	V_NUM DEPT.DEPTNO%TYPE := 10;
BEGIN
	CASE V_NUM 
	 WHEN 10 THEN DBMS_OUTPUT.PUT_LINE('DNAME : ACCOUNTING');
     WHEN 20 THEN DBMS_OUTPUT.PUT_LINE('DNAME : RESEARCH');
     WHEN 30 THEN DBMS_OUTPUT.PUT_LINE('DNAME : SALES');
	 WHEN 40 THEN DBMS_OUTPUT.PUT_LINE('DNAME : OPERATIONS');
     ELSE         DBMS_OUTPUT.PUT_LINE('DNAME : N/A');
    END CASE;
END;
/
```


# 레코드와 컬렉션

## 레코드란? 
>📌 자료형이 각기 다른 데이터를 하나의 변수에 저장하는 데 사용.
>자바의 클래스와 비슷하다.

```PLSQL
TYPE (1)레코드 이름 IS RECORD(
	(2)변수이름 (3)자료형 (4)NOT NULL (5) := , DEFAULT , EXPRESSION 
)
```

| 번호  | 설명                                    |
| --- | ------------------------------------- |
| 1   | 저장할 레코드 이름 지정                         |
| 2   | 레코드 안에 포함할 변수 지정 (여러개 지정가능 `,` 표로 구분) |
| 3   | 변수의 자료형 지정, `%TYPE`, `%ROWTYPE` 지정가능  |
| 4   | 지정한 변수에 `NOT NULL`제약 조건 지정 (생략 가능)    |
| 5   | 기본값 지정 (생략 가능)                        |
### 레코드 정의해서 사용하기 
```PLSQL
DECLARE 
    TYPE REC_DEPT IS RECORD(
        D_NUM NUMBER NOT NULL := 90,
        D_NAME DEPT.DNAME%TYPE,
        D_LOC DEPT.LOC%TYPE
    );
    REC REC_DEPT;
BEGIN
    REC.D_NUM := 55;
    REC.D_NAME := 'ORACLE';
    REC.D_LOC := 'YOUNGIN';
    DBMS_OUTPUT.PUT_LINE('D_NUM : '||REC.D_NUM);
    DBMS_OUTPUT.PUT_LINE('D_NAME : '||REC.D_NAME);
    DBMS_OUTPUT.PUT_LINE('D_LOC : '||REC.D_LOC);
END;
/
```

```
::결과
D_NUM : 55
D_NAME : ORACLE
D_LOC : YOUNGIN

```

### 레코드를 사용한 INSERT
```PLSQL
DECLARE 
    TYPE TP IS RECORD(
    DNUM NUMBER DEFAULT 0,
    DNAME DEPT.DNAME%TYPE,
    DLOC DEPT.LOC%TYPE
    );
    T TP;
BEGIN
    T.DNUM := 99;
    T.DNAME := 'HONGGILDONG';
    T.DLOC := 'SEOUL';
    
    INSERT INTO TEMP_RECORD_EXAMPLE
    VALUES T;
END;
/
```

```
::결과
99	HONGGILDONG	SEOUL
```

### 레코드를 사용한 UPDATE
```PLSQL

DECLARE 
    TYPE TP IS RECORD(
    VNUM NUMBER NOT NULL DEFAULT 0,
    VNAME DEPT.DNAME%TYPE,
    VLOC DEPT.LOC%TYPE
    );
    T TP;
BEGIN
    T.VNUM := 98;
    T.VNAME := '흥민';
    T.VLOC := '영국';
    
    UPDATE TEMP_RECORD_EXAMPLE
    SET ROW = T
    WHERE DEPTNO = 99;
END;
/
SELECT * FROM TEMP_RECORD_EXAMPLE;
-- UPDATE RECORD
```

```
결과::
98	흥민	영국
```

### 레코드를 포함하는 레코드
```PLSQL
DECLARE 
    TYPE TP1 IS RECORD(
        ANUM DEPT.DEPTNO%TYPE,
        ANAME DEPT.DNAME%TYPE,
        ALOC DEPT.LOC%TYPE
    );
    TYPE TP2 IS RECORD(
        BNUM EMP.EMPNO%TYPE,
        BNAME EMP.ENAME%TYPE,
        BINFO TP1
    );
    T2 TP2;
BEGIN
    SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC 
    INTO T2.BNUM, T2.BNAME, T2.BINFO.ANUM, T2.BINFO.ANAME, T2.BINFO.ALOC
    FROM EMP E, DEPT D
    WHERE E.DEPTNO = D.DEPTNO
    AND E.EMPNO = 7788;
    DBMS_OUTPUT.PUT_LINE('EMPNO : '||T2.BNUM);
    DBMS_OUTPUT.PUT_LINE('ENAME : '||T2.BNAME);
    
    DBMS_OUTPUT.PUT_LINE('DEPTNO : '||T2.BINFO.ANUM);
    DBMS_OUTPUT.PUT_LINE('DNAME : '||T2.BINFO.ANAME);
    DBMS_OUTPUT.PUT_LINE('DLOC: '||T2.BINFO.ALOC);
END;
/
-- 레코드를 포함하는 레코드
```

```
결과 ::
EMPNO : 7788
ENAME : SCOTT
DEPTNO : 20
DNAME : RESEARCH
DLOC: DALLAS
```

### 나의 예제
```PLSQL

DECLARE 
    TYPE REC1 IS RECORD(
        DNUM DEPT.DEPTNO%TYPE,
        DNAME DEPT.DNAME%TYPE,
        DLOC DEPT.LOC%TYPE
    );
    TYPE REC2 IS RECORD(
        ENUM EMP.EMPNO%TYPE,
        ENAME EMP.ENAME%TYPE,
        EJOB EMP.JOB%TYPE,
        R1 REC1
    );
    EMP_REC REC2;
BEGIN
    SELECT D.DEPTNO, D.DNAME, D.LOC, E.EMPNO, E.ENAME, E.JOB 
    INTO EMP_REC.R1.DNUM, EMP_REC.R1.DNAME, EMP_REC.R1.DLOC, EMP_REC.ENUM, EMP_REC.ENAME, EMP_REC.EJOB 
    FROM EMP E, DEPT D
    WHERE E.DEPTNO = D.DEPTNO
    AND E.EMPNO = 7839;
    
    DBMS_OUTPUT.PUT_LINE('사원번호 : '||EMP_REC.ENUM);
    DBMS_OUTPUT.PUT_LINE('사원이름 : '||EMP_REC.ENAME);
    DBMS_OUTPUT.PUT_LINE('직   업 : '||EMP_REC.EJOB);
    DBMS_OUTPUT.PUT_LINE('부서번호 : '||EMP_REC.R1.DNUM);
    DBMS_OUTPUT.PUT_LINE('부서이름 : '||EMP_REC.R1.DNAME);
    DBMS_OUTPUT.PUT_LINE('부서위치 : '||EMP_REC.R1.DLOC);
END;
/
```

```
결과::
사원번호 : 7839
사원이름 : KING
직   업 : PRESIDENT
부서번호 : 10
부서이름 : ACCOUNTING
부서위치 : NEW YORK
```
## 자료형이 같은 여러 데이터를 저장하는 컬렉션
> 📌컬렉션은 특정 자료형의 데이터를 여러 개 저장하는 복합 자료형이다. 
> 여러 종류의 데이터를 하나로 묶어 사용하는 레코드를 테이블의 한 행처럼 사용한다면, 
> 컬렉션은 열 또는 테이블과 같은 형태로 사용할 수 있다. 
> `PL/SQL` 에서 사용할 수 있는 컬렉션은 다음과 같이 세 가지 종류가 있다.

> * 연관 배열
> * 중첩 테이블
> * VARRAY

### 연관 배열
> 📌 연관 배열은 `인덱스`라고도 불리는 `KEY`, `VALUE` 형식으로 구성되는 컬렉션이다. 
> 중복되지 않은 유일한 키를 통해 값을 저장하고 불러오는 방식을 사용한다. 
> 연관 배열을 정의할 때 자료형이 `TABLE`인 변수를 다음과 같이 작성한다.

```PLSQL
TYPE (1)연관 배열 이름 IS TABLE OF (2)자료형[NOT NULL]
INDEX BY (3)인덱스형;
```

| 번호  | 설명                                                                                                                                                                    |
| --- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | 작성할 연관 배열 이름을 지정한다.                                                                                                                                                   |
| 2   | 연관 배열 열에 사영할 자료형을 지정한다. <br>이 자료형에는 `VARCHR2`, `DATE`, `NUMBER`와 같은 단일 자료형을 지정할 수 있고, <br>`%TYPE`, `%ROWTYPE` 같은 참조 자료형도 사용할 수 있다. `NOT NULL` 옵션을 사용할 수 있으며, 생략 가능하다. |
| 3   | 키로 사용할 인덱스의 자료형을 지정한다. <br>`BINARY_INTEGER, PLS_INTEGER`같은 정수 또는 `VARCHAR2` 같은 문자 자료형도 사용할 수 있다.                                                                      |
>💡 나의 궁금증 : `PLS_INTEGER`와 `BINARY_INTEGER`의 차이점이 뭘까 ?
> * `PLS_INTEGER` : 특정 플랫폼에서의 워드 크기에 따라 크기가 정해져있음. 표준적인 정수 유형  
> * `BINARY_INTEGER` : 특정 플랫폼에서의 워드 크기에 의존하지 않는다. 
>   
>   일반적으로는 `PLS_INTEGER`를 사용하는것이 좋으나 , 이식성이나 특정 플랫폼의 워드 크기에
>   의존하지 않아야 하는 경우에는 `BINARY_INTEGER`를 사용한다.
### 나의 연관 배열 예제
```PLSQL
DECLARE 
	TYPE TAB_EX IS TABLE OF VARCHAR2(20)
INDEX BY PLS_INTEGER;

	TT TAB_EX;
BEGIN 
	TT(1) := '첫 번째 데이터';
	TT(2) := '두 번째 데이터';
	TT(3) := '세 번째 데이터';
	TT(4) := '네 번째 데이터';

	DBMS_OUTPUT.PUT_LINE('TT(1) : '||TT(1));
	DBMS_OUTPUT.PUT_LINE('TT(2) : '||TT(2));
	DBMS_OUTPUT.PUT_LINE('TT(3) : '||TT(3));
	DBMS_OUTPUT.PUT_LINE('TT(4) : '||TT(4));
END;
/
```

```
결과::
TT(1) : 첫 번째 데이터
TT(2) : 두 번째 데이터
TT(3) : 세 번째 데이터
TT(4) : 네 번째 데이터
```

### 레코드를 활용한 연관 배열
>📌 연관 배열의 자료형에는 레코드를 사용할 수 있다. 
>다양한 자료형을 포함한 레코드를 여러 개 사용할 수 있으므로 마치 테이블과 같은 데이터 
>사용과 저장이 가능하다. 

```PLSQL
DECLARE 
	TYPE REC1 IS RECORD(
		DNUM DEPT.DEPTNO%TYPE,
		DNAME DEPT.DNAME%TYPE
	);
	TYPE TAB1 IS TABLE OF REC1
		INDEX BY PLS_INTEGER;

	TT TAB1;
	IDX PLS_INTEGER := 0;

BEGIN 
	FOR I IN (SELECT DEPTNO, DNAME FROM DEPT) LOOP
	IDX := IDX + 1;
	TT(IDX).DNUM := I.DEPTNO;
	TT(IDX).DNAME := I.DNAME;

	DBMS_OUTPUT.PUT_LINE(
	TT(IDX).DNUM|| ' : ' || TT(IDX).DNAME 
	);
	END LOOP;
END;
/
```

```
결과::
10 : ACCOUNTING
20 : RESEARCH
30 : SALES
40 : OPERATIONS
```

> 📌 만약 특정 테이블의 전체 열과 같은 구성을 가진 연관 배열을 제작한다면 다음과 같이 
> `%ROWTYPE` 을 사용하는 것이 레코드를 정의하는 것보다 간편하다.

```PLSQL
DECLARE 
	TYPE TAB1 IS TABLE OF DEPT%ROWTYPE
	INDEX BY PLS_INTEGER;
TT TAB1;
IDX PLS_INTEGER := 0;

BEGIN 
	FOR I IN (SELECT * FROM DEPT) LOOP
	IDX := IDX + 1;
	TT(IDX).DEPTNO:= I.DEPTNO; 
	TT(IDX).DNAME := I.DNAME;
	TT(IDX).LOC := I.LOC;
	DBMS_OUTPUT.PUT_LINE(
	'부서 번호 : '||TT(IDX).DEPTNO||
	'/ 부서 이름 : '||TT(IDX).DNAME||
	'/ 지역 명 : '||TT(IDX).LOC
	);
	END LOOP;
END;
/
```

```
결과::
부서 번호 : 10/ 부서 이름 : ACCOUNTING/ 지역 명 : NEW YORK
부서 번호 : 20/ 부서 이름 : RESEARCH/ 지역 명 : DALLAS
부서 번호 : 30/ 부서 이름 : SALES/ 지역 명 : CHICAGO
부서 번호 : 40/ 부서 이름 : OPERATIONS/ 지역 명 : BOSTON
```

## 컬렉션 메서드
>📌 오라클에서 컬렉션 사용상의 편의를 위해 제공하는 서브 프로그램

| 메서드      | 설명                                                                                                                                |
| -------- | --------------------------------------------------------------------------------------------------------------------------------- |
| EXIST(N) | 컬렉션에서 N 인덱스의 데이터 존재 여부를 `T/F` 로 반환                                                                                                |
| COUNT    | 컬렉션에 포함되어 있는 요소 개수 반환                                                                                                             |
| LIMIT    | 현재 컬렉션의 최대 크기를 반환 / 최대 크기가 없으면 `NULL` 반환                                                                                          |
| FIRST    | 컬렉션의 첫 번째 인덱스 번호를 반환                                                                                                              |
| LAST     | 컬렉션의 마지막 인덱스 번호를 반환                                                                                                               |
| PRIOR(N) | 컬렉션의 N인덱스 바로 앞 인덱스 값을 반환 / 없다면 `NULL` 반환                                                                                          |
| NEXT(N)  | 컬렉션에서 N 인덱스 바로 다음 인덱스 값을 반환 / 없다면 `NULL`                                                                                          |
| DELETE   | 컬렉션에 저장된 요소를 지우는데 사용<br>* `DELETE`: 컬렉션에 저장된 모든 요소 삭제<br>* `DELETE(N)`: N 인덱스의 컬렉션 요소를 삭제<br>* `DELETE(N, M)`: N 인덱스부터 M 인덱스까지 삭제 |
| EXTEND   | 컬렉션 크기를 증가시킨다.                                                                                                                    |
| TRIM     | 컬렉션 크기를 감소시킨다.                                                                                                                    |
### 컬렉션 메서드 사용하기
```PLSQL
DECLARE 
	TYPE TAB1 IS TABLE OF VARCHAR2(20)
	INDEX BY PLS_INTEGER;
	T1 TAB1;
BEGIN 
	T1(1) := '일번';
	T1(2) := '이번';
	T1(3) := '삼번';
	T1(50) := '오십번';
	DBMS_OUTPUT.PUT_LINE('COUNT : '||T1.COUNT);
	DBMS_OUTPUT.PUT_LINE('FIRST : '||T1.FIRST);
	DBMS_OUTPUT.PUT_LINE('LAST : '||T1.LAST);
	DBMS_OUTPUT.PUT_LINE('PRIOR(50) : '||T1.PRIOR(50));
	DBMS_OUTPUT.PUT_LINE('NEXT(50) : '||T1.NEXT(50));
END;
```

```
결과::
COUNT : 4
FIRST : 1
LAST : 50
PRIOR(50) : 3 -- PRIOR(50) : 50번 인덱스 바로 앞의 인덱스는 3이다.
NEXT(50) :  -- NEXT(50) : 50번 다음의 인덱스는 없다.
```


### 연습문제
```PLSQL
CREATE TABLE EXAMPLE_TABLE AS SELECT * FROM EMP;
SELECT * FROM EMP;
-- EMP 테이블과 동일한 열을 가진 EXAMPLE_TABLE 생성
DECLARE 
    TYPE REC1 IS RECORD(
    ENUM EMP.EMPNO%TYPE,
    ENAME EMP.ENAME%TYPE,
    JOB EMP.JOB%TYPE,
    MGR EMP.MGR%TYPE,
    HIREDATE EMP.HIREDATE%TYPE,
    SAL EMP.SAL%TYPE,
    COMM EMP.COMM%TYPE,
    DEPTNO EMP.DEPTNO%TYPE
    );
    REC REC1; --레코드 생성
BEGIN
    REC.ENUM := 1111;
    REC.ENAME := 'TEST_USER';
    REC.JOB := 'TEST_JOB';
    REC.MGR := NULL;
    REC.HIREDATE := TO_DATE('20180301','YYYYMMDD');
    REC.SAL := 3000;
    REC.DEPTNO := 40;
    INSERT INTO EXAMPLE_TABLE VALUES REC;
END; -- 레코드를 통한 INSERT INTO 
/
```

```결과
1111	TEST_USER	TEST_JOB		18/03/01	3000		40
```