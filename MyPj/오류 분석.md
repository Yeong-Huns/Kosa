# 1. 퇴근 누락 사유서 창이 뜨지 않는 문제 
## 1-1. 자바 로깅

![[Pasted image 20240516043135.png||360]]

> 📌 퇴근 누락 사유서 아무창도 뜨지 않는 모습

```java
ResponseEntity<List<Approval>> approvalList = ApprovalRepository.getInstance().getMemberStatementOfReason(  
        Approval.builder()  
                .memberId(Main.getSessionKey())  
                .approvalType(2)  
                .approvalDate(date)  
                .build());  
System.out.println("getDeptAnnualLeaves 넘기는 값 : " + Main.getSessionKey() +" date : " + date);  
System.out.println("받아오는 에러코드 값 : " + approvalList.getErrorCode() + " 메세지 : " + approvalList.getErrorMessage());
```


![[Pasted image 20240516043200.png]]

> 📌 로그를 찍어본 결과, 조회되는 데이터 없음(list size: 0) 인데도 불구하고 
> 에러코드 값이 0(조회되는 데이터가 있음) 반환되는 것을 확인.
> -> 자바문제가 아니라고 확신

## 1-2. 프로시저 테스트
```plsql
DECLARE
    p_records       SYS_REFCURSOR;
    p_result_code   NUMBER;
    p_result_message VARCHAR2(400);
BEGIN
    approval_package.get_member_statement_of_reason(
        p_member_id => 3,
        p_approval_type => 2,
        p_year => 2024,
        p_month => 3,
        p_records => p_records,
        p_result_code => p_result_code,
        p_result_message => p_result_message
    );

    DBMS_OUTPUT.PUT_LINE('Result Code: ' || p_result_code);
    DBMS_OUTPUT.PUT_LINE('Result Message: ' || p_result_message);

    LOOP
        DECLARE
            v_comfirm         NUMBER;
            v_content         VARCHAR2(400);
            v_annual_leave_date DATE;
        BEGIN
            FETCH p_records INTO v_comfirm, v_content, v_annual_leave_date;
            EXIT WHEN p_records%NOTFOUND;
            DBMS_OUTPUT.PUT_LINE('Comfirm: ' || v_comfirm);
            DBMS_OUTPUT.PUT_LINE('Content: ' || v_content);
            DBMS_OUTPUT.PUT_LINE('Annual Leave Date: ' || v_annual_leave_date);
        END;
    END LOOP;

    CLOSE p_records;
END;
/
```

> 📌 자바와 동등한 조건 세팅 (Id : 3, type: 2, year : 2024, month : 3) 

![[Pasted image 20240516043954.png]]

```plsql
DBMS_OUTPUT.PUT_LINE('Comfirm: ' || v_comfirm);
DBMS_OUTPUT.PUT_LINE('Content: ' || v_content);
DBMS_OUTPUT.PUT_LINE('Annual Leave Date: ' || v_annual_leave_date);
```

> 📌 조회가 됐다면 comfirm , content, annual leave date가 출력 되어야 하는데,
> 조회 결과가 출력되지 않는 중

## 1-3. 데이터 확인

![[Pasted image 20240516044451.png]]

> 📌 member_id 3 으로 조회

![[Pasted image 20240516044437.png]]

> 📌 member_id = 3 은 죄다 연차(approval_type : 1) 기록만 가지고 있다.
> 즉, 퇴근 누락 사유서를 조회시, result_code가 0(조회성공)이 뜰 이유가 전혀 없다.
## 1-4. 프로시저 분석
```plsql
-- 멤버별 퇴근 누락 사유서 조회
    procedure get_member_statement_of_reason(
        p_member_id                     in number,
        p_approval_type                 in number,
        p_year                          in number,
        p_month                         in number,
        p_records                       out sys_refcursor,
        p_result_code                   out number,
        p_result_message                out varchar2)
    as
        v_count                         number;
        v_exist                         number;
    begin
        select count(*)
        into v_exist
        from member
        where member_id = p_member_id;

        if v_exist = 0 then
            p_result_code := 2;
            p_result_message := '존재하지 않는 회원입니다.';
            open p_records for
                    select cast(null as number) as comfirm,
                        cast(null as varchar2(400)) as content,
                        cast(null as date) as annual_leaves_date
                        from dual;
                        return;

        end if;

        select count(*)
        into v_count
        from approval
        where member_member_id = p_member_id
            and extract(year from annual_leave_date) = p_year
            and extract(month from annual_leave_date) = p_month;
	 -- approval type 검증 누락
        open p_records for
            select comfirm, content, annual_leave_date
            from approval
            where member_member_id = p_member_id
                and approval_type = p_approval_type
                and extract(year from annual_leave_date) = p_year
                and extract(month from annual_leave_date) = p_month;
            if v_count > 0 then
                p_result_code := 0;
                p_result_message := '퇴근 누락 사유서 조회 성공';
            else
                p_result_code := 1;
                p_result_message := '조회된 퇴근 누락 사유서가 없습니다.';
            end if;
    exception
        when others then
            p_result_code := sqlcode;
            p_result_message := 'error code 참고';
    end get_member_statement_of_reason;

```

> 📌 approval_type 이 2인 값만 가져와야 하는데, `where`문에 approval_type을 
> 검증하는 조건이 누락되어있다. 
> 연차기록이 조회되었기 때문에 `V_count`가 증가하였고, result_code = 0 , 
> 퇴근 누락 사유서 조회 성공이 들어가고, 
> 커서에선 `and approval_type = p_approval_type` 로 자바에서 입력된
> approval_type과 일치하는 값(2)만 담았으니 아무것도 담기지 않은 
> 빈커서가 반환되었다. 

# 2. 연차 수신함 null 문제
![[Pasted image 20240516045650.png||360]]

> 📌 날짜에 null이 들어오고 있다.

## 2-1. 자바로깅 
![[Pasted image 20240516050159.png]]

> 📌 마찬가지로, 잘 넘어가고 있다. 

## 2-2. 프로시저 테스트

```plsql
DECLARE
    p_records       SYS_REFCURSOR;
    p_result_code   NUMBER;
    p_result_message VARCHAR2(400);
BEGIN
    approval_package.get_dept_approved_annual_leaves(
        p_member_id => 3,
        p_approval_type => 1,
        p_year => 2024,
        p_month => 5,
        p_records => p_records,
        p_result_code => p_result_code,
        p_result_message => p_result_message
    );

    DBMS_OUTPUT.PUT_LINE('Result Code: ' || p_result_code);
    DBMS_OUTPUT.PUT_LINE('Result Message: ' || p_result_message);

    LOOP
        DECLARE
            v_annual_leaves_id NUMBER;
            v_member_id        NUMBER;
            v_mname            VARCHAR2(100);
            v_comfirm          NUMBER;
            v_content          VARCHAR2(200);
            v_approval_date    DATE;
        BEGIN
            FETCH p_records INTO v_annual_leaves_id, v_member_id, v_mname, v_comfirm, v_content, v_approval_date;
            EXIT WHEN p_records%NOTFOUND;
            DBMS_OUTPUT.PUT_LINE('Annual Leaves ID: ' || v_annual_leaves_id);
            DBMS_OUTPUT.PUT_LINE('Member ID: ' || v_member_id);
            DBMS_OUTPUT.PUT_LINE('Member Name: ' || v_mname);
            DBMS_OUTPUT.PUT_LINE('Confirm: ' || v_comfirm);
            DBMS_OUTPUT.PUT_LINE('Content: ' || v_content);
            DBMS_OUTPUT.PUT_LINE('Approval Date: ' || v_approval_date);
        END;
    END LOOP;

    CLOSE p_records;
END;
/
```

![[Pasted image 20240516050314.png]]

> 📌 결과 : Approval_date : `null` 로 들어오는 모습

## 2-3. 데이터 확인
![[Pasted image 20240516050526.png]]

> 📌 딱 봐도 Annual_leave_date 대신 approval_date로 착각하고 만든거 같다. 

## 2-4 프로시저 분석
```plsql
-- 승인대기중인 연차 조회 프로시저
    procedure get_dept_approved_annual_leaves(
        p_member_id                     in number,
        p_approval_type                 in number,
        p_year                          in number,
        p_month                         in number,
        p_records                       out sys_refcursor,
        p_result_code                   out number,
        p_result_message                out varchar2)
    as
        v_dept_deptno                   number;
        v_count                         number;
    begin
        begin
            select dept_deptno 
            into v_dept_deptno 
            from member 
            where member_id = p_member_id;
        exception
            when no_data_found then
                p_result_code := 2;
                p_result_message := '존재하지 않는 회원입니다.';
                open p_records for
                    select cast(null as number) as annual_leaves_id,
                        cast(null as number) as member_id,
                        cast(null as varchar2(100)) as mname,
                        cast(null as number) as comfirm,
                        cast(null as varchar2(200)) as content,
                        cast(null as date) as approval_date
                        from dual
                return;
        end;

        select count(*)
        into v_count
        from approval a
        join member m on a.member_member_id = m.member_id
        where m.dept_deptno = v_dept_deptno
            and a.approval_type = p_approval_type
            and comfirm = 2
            and extract(year from a.annual_leave_date) = p_year
            and extract(month from a.annual_leave_date) = p_month;
        open p_records for
            select annual_leaves_id, member_id, mname, comfirm, content, approval_date 
            from dept_approval_view
            where dept_deptno = v_dept_deptno
                and approval_type = p_approval_type
                and comfirm = 2
                and extract(year from annual_leave_date) = p_year
                and extract(month from annual_leave_date) = p_month;
            if v_count > 0 then
                p_result_code := 0;
                p_result_message := '해당 년/월 부서원 연차 조회 성공';
            else
                p_result_code := 1;
                p_result_message := '해당 년/월 조회된 부서원 연차가 없습니다.';
            end if;
        exception
            when no_data_found then
                p_result_code := 2;
                p_result_message := 'NO_DATA_FOUND';
            when others then
                p_result_code := sqlcode;
                p_result_message := 'error code 참고';
end get_dept_approved_annual_leaves;

```

> 📌 역시나 커서가 `Annual_leave_date` 대신 `approval_date` 를 담고있다.


# 3.결재함 신청시 화면 프리징 문제
> 📌 역시나 예상대로 Error code가 2가 날아오면 IllegalArgumentException으로 
> 중단 시키는게 문제가 되었다. 

```java
try{  
switch (approvalType) {  
    case 1 -> {  
        ResponseEntity<Void> response = ApprovalRepository.getInstance().resisterApproval(  
                Approval.builder()  
                        .memberId(Main.getSessionKey())  
                        .content(reasonTextArea.getText())  
                        .approvalDate(localDate)  
                        .build());  
  
        response.showDialogs();  
    }  
    case 2 -> {  
        ResponseEntity<Void> response = ApprovalRepository.getInstance().insertStatementReason(  
                Approval.builder()  
                        .memberId(Main.getSessionKey())  
                        .content(reasonTextArea.getText())  
                        .approvalDate(localDate)  
                        .build());  
  
        response.showDialogs();  
    }  
}  
} finally {  
    UIController.getInstance().getApprovalView().getApprovalDetail().removeAll();  
    UIController.getInstance().getApprovalView().getApprovalDetail().initUIComponents();  
    UIController.getInstance().getApprovalView().getApprovalDetail().revalidate();  
    UIController.getInstance().getApprovalView().getApprovalDetail().repaint();  
    System.out.println("After switch:");  
    System.out.println("ApprovalType: " + approvalType);  
}
```

> 만약 `switch - case`문에서 Error-code 2 가 발생하면, 자동으로 IllegalArgumentException이 호출되면서, 아래있는 새로고침 로직이 실행되지 않는다.
> finally 구문을 사용하여 에러가 발생하여도 반드시 실행하는걸로 해결

# 프로젝트를 통해 느낀 보완할 점

1. DB에 의존하지말고 더미 데이터를 세팅하여 내가 할 일 부터 하자
2. 프로그램 로직을 짤 때, 어떤식으로 값을 넘겨주고 받아올지 논의를 더 충분히 해야한다.
3. 기능을 개발하다보니 로직을 처리하는 새로운 계층의 필요성을 느꼈다.
하지만 주요로직을 변경하기엔 시간이 없어서 하지 못했는데, 
처음부터 확장이 용이한 설계를 했더라면 아마 가능했을 것이다.




